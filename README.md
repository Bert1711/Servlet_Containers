
## Задача: 
### Осуществить рефакторинг кода.
- Вынести методы в константы. 
- Убрать дублирующийся код.
- Реализовать репозиторий.

Реализуйте репозиторий с учётом того,
что методы репозитория могут вызываться конкурентно, т. е. в разных потоках.

### Как должен работать save: 

Если от клиента приходит пост с id=0, значит,
это создание нового поста. Вы сохраняете его в списке
и присваиваете ему новый id. Достаточно хранить счётчик с целым числом
и увеличивать на 1 при создании каждого нового поста.


Если от клиента приходит пост с id !=0, значит,
это сохранение (обновление) существующего поста.
Вы ищете его в списке по id и обновляете.
Продумайте самостоятельно, что вы будете делать,
если поста с таким id не оказалось: здесь могут быть разные стратегии.


## Реализация 

### Рефакторинг класса MainServlet:

- Вынес константы для путей запросов /api/posts и /api/posts/\d+, чтобы улучшить читаемость кода и сделать его более модифицируемым.
- Вынес методы doGet(), doPost(), и doDelete(), чтобы каждый метод отвечал только за определенный тип запроса.
- Убрал метод init() и использовал конструктор для инициализации контроллера PostController.

### Рефакторинг класса PostRepository:
- Вместо заглушки Collections.emptyList() используем ассоциативный массив. 
Для быстрого доступа к элементам по id лучше использовать потокобезопасный
ассоциативный массив - ConcurrentHashMap<Long, Post>,
где ключом будет id, а значением - сам пост.
- Добавлено поле AtomicInteger counter - оно позволяет увеличивать
или уменьшать значение целочисленной переменной в многопоточной среде
без возникновения состояний гонки или других проблем синхронизации.
Используем его в виде инкремента в создании id поста.

