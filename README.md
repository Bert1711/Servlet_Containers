
## Задача: 
### Осуществить рефакторинг кода.
- Вынести методы в константы. 
- Убрать дублирующийся код.
- Реализовать репозиторий.

Реализуйте репозиторий с учётом того,
что методы репозитория могут вызываться конкурентно, т. е. в разных потоках.

### Как должен работать save: 

Если от клиента приходит пост с id=0, значит,
это создание нового поста. Вы сохраняете его в списке
и присваиваете ему новый id. Достаточно хранить счётчик с целым числом
и увеличивать на 1 при создании каждого нового поста.


Если от клиента приходит пост с id !=0, значит,
это сохранение (обновление) существующего поста.
Вы ищете его в списке по id и обновляете.
Продумайте самостоятельно, что вы будете делать,
если поста с таким id не оказалось: здесь могут быть разные стратегии.


## Реализация 

### Рефакторинг класса MainServlet:

- Вынес константы для путей запросов /api/posts и /api/posts/\d+, чтобы улучшить читаемость кода и сделать его более модифицируемым.
- Вынес методы doGet(), doPost(), и doDelete(), чтобы каждый метод отвечал только за определенный тип запроса.


### Рефакторинг класса PostRepository:
- Вместо заглушки 'Collections.emptyList()' используем ассоциативный массив. 
Для быстрого доступа к элементам по id лучше использовать потокобезопасный
ассоциативный массив - ConcurrentHashMap<Long, Post>,
где ключом будет id, а значением - сам пост.
- Добавлено поле 'AtomicInteger counter' - оно позволяет увеличивать
или уменьшать значение целочисленной переменной в многопоточной среде
без возникновения состояний гонки или других проблем синхронизации.
Используем его в виде инкремента в создании id поста.
- В методе 'save' мы проверяем по какому id пользователь хочет добавить, либо изменить
пост. Если от клиента не приходит в теле запроса id-пост, то id присваивается по инкременту.
Если от клиента приходит id с уже существуещей записи поста, то пост будет изменен. 
Если от клиента приходит id с не существующей записи поста, то пост записывается под этим id.

